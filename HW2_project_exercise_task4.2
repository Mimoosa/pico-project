from machine import Pin, I2C # Import library to control GPIO pins and I2C interface
from ssd1306 import SSD1306_I2C  # Import the SSD1306 OLED display driver
from filefifo import Filefifo # Import library to read data from a FIFO file
import micropython
micropython.alloc_emergency_exception_buf(200) # Allocate buffer for emergency exception handling


# Initialize Filefifo to read data from a file with a buffer size of 10
# The file 'capture01_250Hz.txt' is used as the data source
data = Filefifo(10, name='capture03_250Hz.txt')

# Set up I2C communication for the OLED display
i2c = I2C(1, scl=Pin(15), sda=Pin(14), freq=400000)

# Define OLED screen dimensions
oled_width = 128
oled_height = 64

# Initialize the OLED display with defined dimensions
oled = SSD1306_I2C(oled_width, oled_height, i2c)

# Define parameters for the moving average filter
window_size = 10 # Size of the moving average window

# Define chunk size for processing data in groups
chunk_size = 250 # Number of samples to process in each chunk

# Initialize the horizontal pixel position for plotting
x = 0



def filtering_signals():
    """
    This function filters the signal using a combination of moving average 
    and exponential smoothing for a single chunk of data.
    """
    buffer = [] # Buffer to store the most recent values for the moving average
    alpha = 0.1 # Smoothing factor for exponential moving average
    previous_output = 0 # Initialize the previous output for exponential smoothing
    filtered_values = [] # List to store the filtered values
    
    for _ in range(chunk_size): # Iterate through the number of samples in the chunk
        value = data.get() # Get the next data value from the Filefifo
        buffer.append(value) # Add the value to the buffer
        
        if len(buffer) >= window_size: # Start filtering once the buffer reaches the window size
       
            if len(buffer) > window_size: # If the buffer exceeds the window size, remove the oldest value
                buffer.pop(0) # Remove the first value to maintain a fixed window size
            
            avg_value = sum(buffer) / len(buffer)# Calculate the moving average of the values in the buffer
            
            # Apply exponential moving average formula
            output = alpha * avg_value + (1 - alpha) * previous_output
            previous_output = output  # Update previous output for the next iteration
           
            filtered_values.append(output) # Store the filtered value
            
    return filtered_values



# Process the first chunk to initialize scaling variables
chunk_filtered_values = filtering_signals()  # Filter the signals for the first chunk   
        
max_value = max(chunk_filtered_values) # Find the maximum value of the first chunk

min_value = min(chunk_filtered_values) # Find the minimum value of the first chunk

# Main loop through the data in chunks
for chunk_start in range(0, 6000, chunk_size): # Process chunks of size 'chunk_size' from index 0 to 6000
 
    horizontal_scaling_values = [] # Temporary list for horizontal scaling values
    
    # Filter the signals for the current chunk
    chunk_filtered_values = filtering_signals()
    
    # Process each value in the filtered chunk
    for i in range(len(chunk_filtered_values)):
        
        # Scale the current value to a 0–100 range
        scaled_value = ((chunk_filtered_values[i] - min_value) / (max_value - min_value)) * 100
        horizontal_scaling_values.append(scaled_value)  # Add the scaled value to the horizontal scaling list
        
        # Perform horizontal scaling every 5 values
        if len(horizontal_scaling_values) > 5:
            # Calculate the average of the last 5 scaled values
            horizontal_scaled_value = sum(horizontal_scaling_values) / len(horizontal_scaling_values)
           
            # Scale the averaged value to fit the OLED screen height (0–63)
            y = int(horizontal_scaled_value * (oled_height - 1) / 100) 
          
            # Cap the y value to ensure it fits within the screen limits
            if y < 0:
                y = 0
            elif y > oled_height - 1:
                y = oled_height - 1
            
            # Plot the pixel on the OLED display at position (x, y)
            oled.pixel(x, y, 1)
            x += 1# Move to the next horizontal position
            
            # Clear the horizontal scaling values for the next iteration
            horizontal_scaling_values.clear()
            
            # If the x position exceeds the screen width, refresh the display and show the plotted pixels
            if x > oled_width:
         
                oled.show() # Update the OLED display with the plotted pixels
               
                x = 0 # Reset the x position
                
                oled.fill(0) # Clear the screen for the next frame
    
    # Update the scaling variables for the next chunk
    max_value = max(chunk_filtered_values)

    min_value = min(chunk_filtered_values)
                 
